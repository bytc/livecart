<?php

namespace user;

/**
 * Store user logic (including frontend and backend), including authorization and access control checking
 *
 * @package application/model/user
 * @author Integry Systems <http://integry.com>
 */
class User extends \ActiveRecordModel implements \eav\EavAble
{
	/**
	 * ID of anonymous user that is not authorized
	 *
	 */
	const ANONYMOUS_USER_ID = NULL;

	private $newPassword;

	public $grantedRoles = array();

	public $ID;
	public $defaultShippingAddressID;
	public $defaultBillingAddressID;
	public $userGroupID;
	
	public $eavObjectID;
	
	public $locale;
	public $email;
	public $password;
	public $firstName;
	public $lastName;
	public $companyName;
	public $dateCreated;
	public $isEnabled;
	public $preferences;

	protected $hasBackendAccess;

	public function initialize()
	{
		$this->addBehavior(new \Phalcon\Mvc\Model\Behavior\Timestampable(
			array(
				'beforeCreate' => array(
					'field' => 'dateCreated',
					'format' => 'Y-m-d'
				)
			)
		));

		$this->belongsTo('userGroupID', 'user\UserGroup', 'ID', array('alias' => 'UserGroup'));
		$this->hasOne('eavObjectID', 'eav\EavObject', 'ID', array('foreignKey' => array('action' => \Phalcon\Mvc\Model\Relation::ACTION_CASCADE), 'alias' => 'EavObject'));
	}

    public function validation()
    {
		$emailErr = $this->getDI()->get('application')->translate('_err_not_unique_email');
		$emailErr = str_replace('%1', $this->getDI()->get('url')->get('user/login', array('email' => $this->getDI()->get('request')->get('email'))), $emailErr);

        $this->validate(new \Phalcon\Mvc\Model\Validator\Uniqueness(
            array(
                "field"   => "email",
                "message" => $emailErr
            )
        ));

        return $this->validationHasFailed() != true;
    }

	/*####################  Static method implementations ####################*/

	/**
	 * Create new user
	 *
	 * @param string $email Email
	 * @param string $password Password
	 * @param UserGroup $userGroup User group
	 *
	 * @return User
	 */
	public static function getNewInstance($email, $password = null, UserGroup $userGroup = null)
	{
		$instance = new self();
		$instance->email = $email;
		$instance->photoReviewed = 1;

		if ($userGroup)
		{
			$instance->userGroup = $userGroup;
		}

		if ($password)
		{
			$instance->setPassword($password);
		}

		return $instance;
	}

	/**
	 * Load users set
	 *
	 * @param ARSelectFilter $filter
	 * @param bool $loadReferencedRecords
	 *
	 * @return ARSet
	 */
	public static function getRecordSet(ARSelectFilter $filter, $loadReferencedRecords = false)
	{
		return parent::getRecordSet(__CLASS__, $filter, $loadReferencedRecords);
	}

	/*####################  Instance retrieval ####################*/

	/**
	 * Load users that belong to the specified group
	 *
	 * @param DeliveryZone $deliveryZone
	 * @param bool $loadReferencedRecords
	 *
	 * @return ARSet
	 */
	public static function getRecordSetByGroup(UserGroup $userGroup = null, ARSelectFilter $filter = null, $loadReferencedRecords = array('UserGroup'))
	{
		if(!$filter)
		{
			$filter = new ARSelectFilter();
		}

		if(!$userGroup)
		{
			$filter->andWhere(new IsNullCond(new ARFieldHandle(__CLASS__, "userGroupID")));
		}
		else
		{
			$filter->andWhere(new EqualsCond(new ARFieldHandle(__CLASS__, "userGroupID"), $userGroup->getID()));
		}

		return self::getRecordSet($filter, $loadReferencedRecords);
	}

	/**
	 * Gets an instance of user by using login information
	 *
	 * @param string $email
	 * @param string $password
	 * @return mixed User instance or null if user is not found
	 */
	public static function getInstanceByLogin($email, $password)
	{
		$user = User::query()->where('email = :email: AND isEnabled = 1')->bind(array('email' => $email))->execute()->getFirst();

		if ($user && $user->isPasswordValid($password))
		{
			return $user;
		}
	}

	/**
	 * Gets an instance of user by using user's e-mail
	 *
	 * @param string $email
	 * @return mixed User instance or null if user is not found
	 */
	public static function getInstanceByEmail($email)
	{
		return User::query()->where('email = :email:')->bind(array('email' => $email))->execute()->getFirst();
	}

	/*####################  Value retrieval and manipulation ####################*/

	public function isAnonymous()
	{
		return $this->getID() == self::ANONYMOUS_USER_ID;
	}

	/**
	 * Generate a random password
	 *
	 * @return string
	 */
	public function getAutoGeneratedPassword($length = 8)
	{
		$chars = array();
		for ($k = 1; $k <= $length; $k++)
		{
			$chars[] = chr(rand(97, 122));
		}

		return implode('', $chars);
	}

	/**
	 * Change user password
	 *
	 * @param string $password New password
	 */
	public function setPassword($password)
	{
		$salt = $this->getAutoGeneratedPassword(16);
		$saltedPassword = md5($password . $salt);
		$this->password = $saltedPassword . ':' . $salt;
		$this->newPassword = $password;
	}

	public function getPassword()
	{
		return $this->newPassword;
	}

	public function isPasswordValid($password)
	{
		$password = trim($password);
		$parts = explode(':', $this->password);
		$hash = array_shift($parts);
		$salt = array_shift($parts);

		return md5($password . $salt) == $hash;
	}

	/**
	 * Checks if a user can access a particular controller/action identified by a role string (handle)
	 *
	 * Role string represents hierarchial role, that grants access to a given node:
	 * rootNode.someNode.lastNode
	 *
	 * (i.e. admin.store.catalog) this role string identifies that user has access to
	 * all actions/controller that are mapped to this string (admin.store.catalog.*)
	 *
	 * @param string $roleName
	 * @return bool
	 */
	public function hasAccess($roleName)
	{
		if ($this->hasBackendAccess() || !empty($this->grantedRoles[$roleName]))
		{
			return true;
		}

		// no role provided
		if (!$roleName)
		{
			return true;
		}

		if (!$this->getID())
		{
			return false;
		}

		if ('login' == $roleName)
		{
			return $this->getID() > 0;
		}
		else if ('backend' == $roleName)
		{
			return $this->hasBackendAccess();
		}

		if ($this->isAnonymous())
		{
			return false;
		}
		else
		{
			// @todo: add group check
			return true;
			
			$group = $this->getUserGroup();

			if (!$group)
			{
				return false;
			}

			return $group->hasAccess($roleName);
		}
	}

	public function allowBackendAccess()
	{
		$this->hasBackendAccess = true;
	}

	/**
	 *	Dynamically grant access to a role
	 */
	public function grantAccess($roleName)
	{
		$this->grantedRoles[$roleName] = true;
	}

	/**
	 * Determine if the user is allowed to access the admin backend (has at least one permission)
	 *
	 * @return boolean
	 */
	public function hasBackendAccess()
	{
		if ($this->hasBackendAccess)
		{
			return true;
		}

		if ($this->isAnonymous())
		{
			return false;
		}
		else
		{
			return false;
//			$this->load(array('UserGroup'));
			if (!$this->userGroup)
			{
				return false;
			}
			else
			{
				$this->userGroup->load();
			}

			$this->userGroup->loadRoles();

			return count($this->userGroup->getAppliedRoles()) > 0;
		}
	}

	/**
	 * Check's if this user is loged in. This function will return true only if this
	 * user is loged within this particular session.
	 *
	 * In short that means that this function will return true only if you are this
	 * user and you are currently loged in
	 *
	 * @return boolean
	 */
	public function isLoggedIn()
	{
		return ($this->getID() != self::ANONYMOUS_USER_ID);
	}

	public function setPreference($key, $value)
	{
		$preferences = $this->preferences ? unserialize($this->preferences) : array();
		$preferences[$key] = $value;
		$this->preferences = serialize($preferences);
	}

	public function getPreference($key)
	{
		$preferences = $this->preferences ? unserialize($this->preferences) : array();
		if (isset($preferences[$key]))
		{
			return $preferences[$key];
		}

		return null;
	}

	/**
	 * Get user full name inlcuding both first and last names
	 *
	 * @return string
	 */
	public function getName()
	{
		return $this->firstName . ' ' . $this->lastName;
	}

	public function invalidateSessionCache()
	{
		if ($this->isAnonymous())
		{
			return;
		}

		$f = new ARUpdateFilter(eq(f('SessionData.userID'), $this->getID()));
		$f->addModifier('cacheUpdated', 0);
		self::updateRecordSet('SessionData', $f);
	}

	/*####################  Saving ####################*/
	public function beforeCreate()
	{
		$this->photoReviewed = 1;
		
		parent::beforeCreate();
		
		/*
		if ($subscriber = NewsletterSubscriber::getInstanceByEmail($this->email))
		{
			$subscriber->user = $this;
		}
		else
		{
			$subscriber = NewsletterSubscriber::getNewInstanceByUser($this);
			$subscriber->isEnabled = false;
			$subscriber->save();
		}

		$subscriber->confirmationCode = '';
		$subscriber->save();
		*/
	}

	/**
	 * Save user in the database
	 */
	public function beforeSave()
	{
		// auto-generate password if not set
		if (!$this->password)
		{
			$this->setPassword($this->getAutoGeneratedPassword());
		}
	}

	/*####################  Data array transformation ####################*/

	/*
	public function toArray($args = null)
	{
		$array = parent::toArray($args);
		$array['newPassword'] = $this->newPassword;

		return $array;
	}
	*/

	public static function transformArray($array, ARSchema $schema)
	{
		$array = parent::transformArray($array, $schema);
		$array['fullName'] = $array['firstName'] . ' ' . $array['lastName'];

		return $array;
	}

	public function getFullName()
	{
		return $this->firstName . ' ' . $this->lastName;
	}

	/*####################  Get related objects ####################*/

	/**
	 * Load user address
	 */
	public function loadAddresses()
	{


		if ($this->defaultBillingAddress)
		{
			$this->defaultBillingAddress->load(array('UserAddress'));
		}

		if ($this->defaultShippingAddress)
		{
			$this->defaultShippingAddress->load(array('UserAddress'));
		}
	}

	public function getorderBy($id)
	{
		$f = query::query()->where('CustomerOrder.ID = :CustomerOrder.ID:', array('CustomerOrder.ID' => $id));
		$f->andWhere('CustomerOrder.userID = :CustomerOrder.userID:', array('CustomerOrder.userID' => $this->getID()));
		$f->andWhere('CustomerOrder.isFinalized = :CustomerOrder.isFinalized:', array('CustomerOrder.isFinalized' => true));

		$s = ActiveRecordModel::getRecordSet('CustomerOrder', $f, ActiveRecordModel::LOAD_REFERENCES);
		if ($s->count())
		{
			$order = $s->shift();
			$order->loadAll();
			return $order;
		}
	}

	public function getBillingAddressArray($defaultFirst = true)
	{
		if (!$this->isAnonymous())
		{
			return ActiveRecordModel::getRecordSetArray('BillingAddress', $this->getBillingAddressFilter($defaultFirst), array('UserAddress'));
		}
		else if ($this->defaultBillingAddress)
		{
			return array($this->defaultBillingAddress->toArray());
		}
	}

	public function getBillingAddressSet($defaultFirst = true)
	{
		return ActiveRecordModel::getRecordSet('BillingAddress', $this->getBillingAddressFilter($defaultFirst), array('UserAddress'));
	}

	public function getShippingAddressArray($defaultFirst = true)
	{
		if (!$this->isAnonymous())
		{
			return ActiveRecordModel::getRecordSetArray('ShippingAddress', $this->getShippingAddressFilter($defaultFirst), array('UserAddress'));
		}
		else if ($this->defaultShippingAddress)
		{
			return array($this->defaultShippingAddress->toArray());
		}
	}

	public function getShippingAddressSet($defaultFirst = true)
	{
		return ActiveRecordModel::getRecordSet('ShippingAddress', $this->getShippingAddressFilter($defaultFirst), array('UserAddress'));
	}

	public function countInvoices($filter = null)
	{
		$filter = $filter ? $filter : new ARSelectFilter();
		$filter->andWhere(
			new AndChainCondition(array(
				'CustomerOrder.userID = :CustomerOrder.userID:', array('CustomerOrder.userID' => $this->getID()),
				'CustomerOrder.isRecurring = :CustomerOrder.isRecurring:', array('CustomerOrder.isRecurring' => 1),
				new IsNotNullCond('CustomerOrder.parentID')
				)
			)
		);
		return ActiveRecordModel::getRecordCount('CustomerOrder', $filter);
	}

	public function countPendingInvoices()
	{
		$filter = new ARSelectFilter();
		$filter->setCondition('CustomerOrder.isPaid = :CustomerOrder.isPaid:', array('CustomerOrder.isPaid' => 0));

		return $this->countInvoices($filter);
	}

	public function hasInvoices($filter = null)
	{
		if ($filter)
		{
			$filter->limit(1);
		}
		return (bool)$this->countInvoices($filter);
	}

	public function hasPendingInvoices()
	{
		$filter = new ARSelectFilter();
		$filter->setCondition('CustomerOrder.isPaid = :CustomerOrder.isPaid:', array('CustomerOrder.isPaid' => 0));
		$filter->limit(1);

		return (bool)$this->countInvoices($filter);
	}

	private function getShippingAddressFilter($defaultFirst = true)
	{
		$f = new ARSelectFilter();
		$f->setCondition('ShippingAddress.userID = :ShippingAddress.userID:', array('ShippingAddress.userID' => $this->getID()));
		if (!$defaultFirst)
		{
			$f->orderBy(new ARExpressionHandle('ID = ' . $this->defaultShippingAddress->getID()));
		}

		return $f;
	}

	private function getBillingAddressFilter($defaultFirst = true)
	{
		$f = new ARSelectFilter();
		$f->setCondition('BillingAddress.userID = :BillingAddress.userID:', array('BillingAddress.userID' => $this->getID()));
		if (!$defaultFirst)
		{
			$f->orderBy(new ARExpressionHandle('ID = ' . $this->defaultBillingAddress->getID()));
		}

		return $f;
	}

	public function serialize($skippedRelations = array(), $properties = array())
	{
		$properties[] = 'specificationInstance';

		foreach (array('defaultShippingAddressID', 'defaultBillingAddressID') as $addr)
		{
			$skippedRelations[] = $addr;
			$addr = substr($addr, 0, -2);
			$key = 'addr_' . $addr;

			if ($this->$addr)
			{
				$this->$key = $this->$addr->userAddress;
				$properties[] = $key;
			}
		}

		return parent::serialize($skippedRelations, $properties);
	}

	public function unserialize($serialized)
	{
		//die($serialized);
		parent::unserialize($serialized);

		foreach (array('defaultShippingAddressID', 'defaultBillingAddressID') as $addr)
		{
			$addr = substr($addr, 0, -2);
			$key = 'addr_' . $addr;

			if ($this->$key)
			{
				$class = substr($addr, 7);
				$this->$addr = $class::getNewInstance($this, $this->$key);
			}
		}
	}
}

?>
